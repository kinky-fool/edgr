#!/usr/bin/perl

use strict;
use warnings;

use Proc::Killall;
use Sessions;

my $conf_file   = "$ENV{HOME}/.config/sessions";
# Read config file and command line args and populate %$state
my $state       = init_state($conf_file);

$$state{time_start} = time();
$$state{go_down} = 3 + plus_or_minus(2);
$$state{pace_dir} = -1;
# Reduce chances of starting going down
if (int(rand($$state{go_down}))) {
  $$state{go_down} = 0;
  $$state{pace_dir} = 1;
}

my $field = $$state{pace_max} - $$state{pace_min};

if ($field < 0) {
  printf STDERR "max_pace lower than min_pace; configuration error.\n";
  exit 1;
}

if ($$state{pace_cur} == 0) {
  # Set the starting pace to just above the low endzone
  $$state{pace_cur} = $$state{pace_min} +
                      int($field * ($$state{endzone_low} / 100)) + 5;
}


if ($$state{dice_count} > 0) {
  $$state{time_extra} = 0;
  my @rolls = ();
  for (1 .. $$state{dice_count} + $$state{extra_high} + $$state{extra_low}) {
    push @rolls,int(rand($$state{dice_sides}) + 1);
  }
  @rolls = sort { $a <=> $b } @rolls;

  $$state{time_min} = 0;
  foreach my $die (@rolls[0 .. $$state{dice_count}-1]) {
    $$state{time_min} += $die;
  }

  $$state{time_max} = 0;
  foreach my $die (@rolls[$#rolls - ($$state{dice_count}-1) .. $#rolls]) {
    $$state{time_max} += $die;
  }

  my @lows  = @rolls[0 .. $$state{extra_low}-1];
  my @highs = @rolls[$#rolls - $$state{extra_high} + 1 .. $#rolls];
  my @used  = @rolls[$$state{extra_low} .. $#rolls - $$state{extra_high}];
  printf "Dice Rolls: %s [ %s ] %s\n","@lows","@used","@highs";

  $$state{time_end} = 0;
  foreach my $die (@used) {
    $$state{time_end} += $die;
  }
} else {
  my @times = ();
  for (1 .. 1 + $$state{extra_high} + $$state{extra_low}) {
    my $time = int(rand($$state{time_max} - $$state{time_min} + 1));
    $time += $$state{time_min};
    push @times,$time;
  }
  @times = sort { $a <=> $b } @times;

  my @lows  = @times[0 .. $$state{extra_low} - 1];
  my @highs = @times[$#times - $$state{extra_high} + 1 .. $#times];
  my $used  = $times[$$state{extra_low}];
  printf "Times: %s [ %s ] %s\n","@lows","$used","@highs";

  $$state{time_min} = $times[0];
  $$state{time_max} = $times[$#times];
  $$state{time_end} = $used;
}

# Convert times into seconds
$$state{time_min} = fuzzy($$state{time_min} * 60,$$state{fuzzify});
$$state{time_max} = fuzzy($$state{time_max} * 60,$$state{fuzzify});
$$state{time_end} = fuzzy($$state{time_end} * 60,$$state{fuzzify});

if ($$state{time_min} > $$state{time_end}) {
  my $temp = $$state{time_min};
  $$state{time_min} = $$state{time_end};
  $$state{time_end} = $temp;
}

if ($$state{time_end} > $$state{time_max}) {
  my $temp = $$state{time_end};
  $$state{time_end} = $$state{time_max};
  $$state{time_max} = $temp;
}

# Initialize the session
my $finalized   = 0;
if (open my $session_fh,'>',"$$state{session_script}") {
  truncate $session_fh,0;
  close $session_fh;
} else {
  error_msg("Unable to open session program file: $!",1);
}

while ($finalized == 0) {
  # Twiddle time_end
  if ($$state{time_add_pct} > rand(100)) {
    $$state{time_end} += fuzzy(20,2);
    if ($$state{time_end} > $$state{time_max}) {
      $$state{time_end} = $$state{time_max};
    }
  }

  if ($$state{time_sub_pct} > rand(100)) {
    $$state{time_end} -= fuzzy(20,2);
    if ($$state{time_end} < $$state{time_min}) {
      $$state{time_end} = $$state{time_min};
    }
  }

  extend_session($state);

  if ($$state{time_elapsed} > $$state{time_min}) {
    if ($$state{time_elapsed} > $$state{time_max}) {
      $finalized = 1;
    }
    if ($$state{time_elapsed} > $$state{time_end}) {
      $finalized = 1;
    }
  }
}

$$state{time_orig} = $$state{time_elapsed};

if ($$state{prize_on} and !int(rand(6))) {
  $$state{prize_armed} = 1;
}

write_config($$state{state_file},$state);

# Start the slideshow
my $slideshow_pid = fork();
if (!defined $slideshow_pid) {
  error_msg("Cannot fork() - aborting: $!",1);
}

if ($slideshow_pid == 0) {
  sexy_slideshow($state);
  exit 0;
}

my $ctronome_pid = fork();
if (!defined $ctronome_pid) {
  error_msg("Cannot fork() - aborting: $!",2);
}

if ($ctronome_pid == 0) {
  begin_session($state);
  exit 0;
}

waitpid -1,0;
do_cleanup();
exit 0;

sub begin_session {
  my $state = shift;

  my $command  = "aoss $$state{ctronome} -c 1 -w1 $$state{tick_file} ";
     $command .= "-w2 $$state{tock_file} -p $$state{session_script}";
  if (open my $metronome_pipe,'-|',"$command 2>/dev/null") {
    local $SIG{HUP} = sub { print "foo\n"; close $metronome_pipe; exit 0 };
    while (<$metronome_pipe>) {
      my $line = $_;
      chomp $line;
      if ($line =~ /^# start/) {
        $state = read_config($$state{state_file});
        if ($$state{bonus_chance} > int(rand($$state{bonus_max}))) {
          if ($$state{bonus_rank} > 0) {
            $$state{bonus_rank} += int(rand($$state{bonus_bonus}));
          }
          write_config($$state{state_file},$state);
        }
      }
    }
    close $metronome_pipe;
  } else {
    error_msg("Unable to open pipe: $!",3);
  }
}

sub pick_images {
  my $dirs  = shift;
  my $count = shift;

  my $multiplier = 3;
  my $errors = 0;

  my @pool = ();
  foreach my $glob (split(/:/,$dirs)) {
    foreach my $dir (glob $glob) {
      if (opendir my $dir_fh,"$dir") {
        my @files = grep { /.(jpe?g|gif|bmp|nef|cr2|png)$/i } readdir $dir_fh;
        @files = map { "$dir/" . $_ } @files;
        my $end = $count - 1;
        if ($end > $#files) {
          $end = $#files;
        }
        for my $loop (1 .. $multiplier) {
          fisher_yates_shuffle(\@files);
          push @pool,@files[0 .. $end];
        }
        closedir $dir_fh;
      } else {
        $errors++;
        error_msg("Unable to opendir $dir: $!",0);
      }
    }
  }

  if ($errors == 0) {
    fisher_yates_shuffle(\@pool);
    return @pool[1 .. $count];
  } else {
    return;
  }
}

sub sexy_slideshow {
  my $state = shift;

  my @playlist  = pick_images(
                      "$$state{image_prize_dirs}:$$state{image_bonus_dirs}",
                      $$state{pics_seed}
                    );
  push @playlist, pick_images($$state{image_bonus_dirs},$$state{pics_bonus});
  push @playlist, pick_images($$state{image_prize_dirs},$$state{pics_prize});
  push @playlist, pick_images($$state{image_random_dirs},$$state{pics_random});

  fisher_yates_shuffle(\@playlist);

  if (open my $playlist_fh,'>',$$state{image_playlist}) {
    foreach my $image (@playlist) {
      print $playlist_fh "$image\n";
    }
    close $playlist_fh;
  } else {
    error_msg("Unable to open image playlist: $!",4);
  }

  my $command  = "$$state{image_viewer} --info '$$state{image_checker} '%f'' ";
     $command .= "--scale-down -Y -F --fontpath '$ENV{HOME}/.fonts/' ";
     $command .= "-D $$state{image_delay} --font 'FiraMono-Medium/32' ";
     $command .= "-Z -f $$state{image_playlist}";

  exec "$command >/dev/null 2>&1";
}

sub do_cleanup {
  killall 'HUP', 'feh';
  killall 'HUP', 'ctronome';

  $state = read_config($$state{state_file});

  my $real_elapsed  = time() - $$state{time_start};
  my $added         = $$state{time_elapsed} - $$state{time_orig};
  my $remaining     = $$state{time_elapsed} - $real_elapsed;

  printf "Session Length: %s [ %s ] %s\n",
    sec_to_human($$state{time_min}),
    sec_to_human($$state{time_orig}),
    sec_to_human($$state{time_max});
  printf "Elapsed Time:   %s\n",sec_to_human($real_elapsed);
  printf "Added Time:     %s\n",sec_to_human($added);

  if (int($remaining) > 0) {
    printf "Remaining Time: %s\n", sec_to_human($remaining);
  }

  if (-f $$state{state_file}) {
    unlink $$state{state_file};
  }

  if (-f $$state{session_script}) {
    unlink $$state{session_script};
  }

  if (-f $$state{image_playlist}) {
    unlink $$state{image_playlist};
  }
}
