#!/usr/bin/perl

use strict;
use warnings;

use Proc::Killall;
use Sessions;

my $conf_file   = "$ENV{HOME}/.config/sessions";
# Read config file and command line args and populate %$state
my $state       = set_state($conf_file);

$$state{time_start} = time();
$$state{go_down} = 3 + plus_or_minus(2);
$$state{pace_dir} = -1;
# Reduce chances of starting going down
if (int(rand($$state{go_down}))) {
  $$state{go_down} = 0;
  $$state{pace_dir} = 1;
}

my $field = $$state{pace_max} - $$state{pace_min};

if ($field < 0) {
  printf STDERR "max_pace lower than min_pace; configuration error.\n";
  exit 1;
}

if ($$state{pace_cur} == 0) {
  # Set the starting pace to just above the low endzone
  $$state{pace_cur} = $$state{pace_min} +
                      int($field * ($$state{endzone_low} / 100)) + 5;
}

# Convert times into seconds
$$state{time_min} = $$state{time_min} * 60;
$$state{time_max} = $$state{time_max} * 60;

$$state{time_extra} = $$state{time_max} - $$state{time_min};

if ($$state{dice_count} > 0) {
  $$state{time_extra} = 0;
  my @rolls = ();
  for (1 .. $$state{dice_count} + $$state{dice_high} + $$state{dice_low}) {
    push @rolls,int(rand($$state{dice_sides}) + 1);
  }
  @rolls = sort { $a <=> $b } @rolls;
  my @lows  = @rolls[0 .. $$state{dice_low}-1];
  my @highs = @rolls[$#rolls - $$state{dice_high} + 1 .. $#rolls];
  my @used  = @rolls[$$state{dice_low} .. $#rolls - $$state{dice_high}];
  printf "Dice Rolls: %s [ %s ] %s\n","@lows","@used","@highs";
  foreach my $spots (@used) {
    $$state{time_extra} += $spots * 60;
  }
}

if ($$state{fuzzify}) {
  $$state{time_min}   = fuzzy($$state{time_min});
  $$state{time_extra} = fuzzy($$state{time_extra});
}

$$state{time_max} = $$state{time_min} + $$state{time_extra};
$$state{time_run} = $$state{time_min} + int($$state{time_extra} / 3);

# Initialize the session
my $finalized   = 0;
if (open my $session_fh,'>',"$$state{session_script}") {
  truncate $session_fh,0;
  close $session_fh;
} else {
  error_msg("Unable to open session program file: $!",1);
}

while ($finalized == 0) {
  # Twiddle time_run
  if ($$state{time_add_pct} > rand(100)) {
    $$state{time_run} += fuzzy(int($$state{time_extra} / 60 * 3));
    if ($$state{time_run} > $$state{time_max}) {
      $$state{time_run} = $$state{time_max};
    }
  }

  if ($$state{time_sub_pct} > rand(100)) {
    $$state{time_run} -= fuzzy(int($$state{time_extra} / 60 * 3));
    if ($$state{time_run} < $$state{time_min}) {
      $$state{time_run} = $$state{time_min};
    }
  }

  extend_session($state);

  if ($$state{time_elapsed} > $$state{time_min}) {
    if ($$state{time_elapsed} > $$state{time_max}) {
      $finalized = 1;
    }
    if ($$state{time_elapsed} > $$state{time_run}) {
      $finalized = 1;
    }
  }
}

$$state{time_orig} = $$state{time_elapsed};

if (!int(rand(6))) {
  $$state{icy_armed} = 1;
}

write_config($$state{state_file},$state);

# Start the slideshow
my $slideshow_pid = fork();
if (!defined $slideshow_pid) {
  error_msg("Cannot fork() - aborting: $!",1);
}

if ($slideshow_pid == 0) {
  sexy_slideshow($state);
  exit 0;
}

my $ctronome_pid = fork();
if (!defined $ctronome_pid) {
  error_msg("Cannot fork() - aborting: $!",2);
}

if ($ctronome_pid == 0) {
  begin_session($state);
  exit 0;
}

waitpid -1,0;
do_cleanup();
exit 0;

sub begin_session {
  my $state = shift;

  my $command  = "aoss $$state{ctronome} -c 1 -w1 $$state{tick_file} ";
     $command .= "-w2 $$state{tock_file} -p $$state{session_script}";
  if (open my $metronome_pipe,'-|',"$command 2>/dev/null") {
    local $SIG{HUP} = sub { print "foo\n"; close $metronome_pipe; exit 0 };
    while (<$metronome_pipe>) {
      my $line = $_;
      chomp $line;
      if ($line =~ /^# start/) {
        if ($$state{icy_chance} > rand($$state{icy_chance_max})) {
          $$state{bonus_active} += $$state{bonus_rank};
          write_config($$state{state_file},$state);
        }
      }
    }
    close $metronome_pipe;
  } else {
    error_msg("Unable to open pipe: $!",3);
  }
}

sub pick_images {
  my $dirs  = shift;
  my $count = shift;

  my $multiplier = 5;
  my $errors = 0;

  my @pool = ();
  foreach my $glob (split(/:/,$dirs)) {
    foreach my $dir (glob $glob) {
      if (opendir my $dir_fh,"$dir") {
        my @files = grep { /.(jpe?g|gif|bmp|nef|cr2|png)$/i } readdir $dir_fh;
        @files = map { "$dir/" . $_ } @files;
        my $end = $count - 1;
        if ($end > $#files) {
          $end = $#files;
        }
        for my $loop (1 .. $multiplier) {
          fisher_yates_shuffle(\@files);
          push @pool,@files[0 .. $end];
        }
        closedir $dir_fh;
      } else {
        $errors++;
        error_msg("Unable to opendir $dir: $!",0);
      }
    }
  }

  if ($errors == 0) {
    fisher_yates_shuffle(\@pool);
    return @pool[1 .. $count];
  } else {
    return;
  }
}

sub sexy_slideshow {
  my $state = shift;

  my @playlist  = pick_images(
                      "$$state{image_prize_dirs}:$$state{image_bonus_dirs}",
                      $$state{pics_seed}
                    );
  push @playlist, pick_images($$state{image_bonus_dirs},$$state{pics_bonus});
  push @playlist, pick_images($$state{image_prize_dirs},$$state{pics_prize});
  push @playlist, pick_images($$state{image_random_dirs},$$state{pics_random});

  fisher_yates_shuffle(\@playlist);

  if (open my $playlist_fh,'>',$$state{image_playlist}) {
    foreach my $image (@playlist) {
      print $playlist_fh "$image\n";
    }
    close $playlist_fh;
  } else {
    error_msg("Unable to open image playlist: $!",4);
  }

  my $command  = "$$state{image_viewer} --info '$$state{image_checker} '%f'' ";
     $command .= "--scale-down -Y -F --fontpath '$ENV{HOME}/.fonts/' ";
     $command .= "-D $$state{image_delay} --font 'FiraMono-Medium/32' ";
     $command .= "-Z -f $$state{image_playlist}";

  exec "$command >/dev/null 2>&1";
}

sub do_cleanup {
  killall 'HUP', 'feh';
  killall 'HUP', 'ctronome';

  $state = set_state($$state{state_file});

  printf "Session Length: %s [ %s ] %s\n",
    sec_to_human($$state{time_min}),
    sec_to_human($$state{time_elapsed}),
    sec_to_human($$state{time_max});
  printf "Elapsed Time:   %s\n",sec_to_human(time() - $$state{time_start});
  printf "Added Time:     %s\n",
    sec_to_human($$state{time_elapsed} - $$state{time_orig});

  if (-f $$state{state_file}) {
    unlink $$state{state_file};
  }

  if (-f $$state{session_script}) {
    unlink $$state{session_script};
  }

  if (-f $$state{image_playlist}) {
    unlink $$state{image_playlist};
  }
}
