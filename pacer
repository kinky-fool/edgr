#!/usr/bin/perl

use strict;
use warnings;

use Math::Random;
use Getopt::Long;

srand("$$" . time);

my $hard_max    = 180;
my $hard_min    = 80;
my $base_max    = $hard_min + ($hard_max - $hard_min) * 7 / 10;
my $base_min    = $hard_min + ($hard_max - $hard_min) * 3 / 10;

my $beat_maker  = "$ENV{HOME}/toys/change-pace";
my $min         = $base_min;
my $max         = $base_max;

my $evil        = 2;
my $maxed       = 0;
my $max_count   = 10;
my $count       = $max_count;
my $pace        = 0;

my @dice        = ();

my $minutes     = 15;
my $seconds     = 0;

GetOptions(
  "hardmax=i" => \$hard_max,
  "hardmin=i" => \$hard_min,
  "max=i"     => \$max,
  "min=i"     => \$min,
  "pace=i"    => \$pace,
  "evil=i"    => \$evil,
  "count=i"   => \$count,
  "maxed=i"   => \$maxed,
  "m=f"       => \$minutes,
  "dice=s"    => \@dice,
) or die("Error in args.\n");


my $direction   = 'up';
my $elapsed     = 0;

if ($pace == 0) {
  $pace = int(rand(($max - $min) / 3)) + $min;
}
$seconds = $minutes * 60;

if (@dice) {
  $seconds = 0;
  foreach my $dice (@dice) {
    my ($count,$sides,$low,$high) = split(/:/,$dice);
    if (!$sides) {
      $sides = 6;
    }
    if (!$low) {
      $low = 0;
    }
    if (!$high) {
      $high = 0;
    }
    my @rolls = ();
    for (1 .. $count + $low + $high) {
      push(@rolls,int(rand($sides)+1));
    }
    my @used = ();
    # Discard $low lowest dice
    @used = (sort { $a <=> $b } @rolls)[$low .. $#rolls];
    # Discard $high highest dice
    @used = (sort { $b <=> $a } @used)[$high .. $#used];
    foreach my $spots (@used) {
      $seconds += $spots * 60;
    }
  }
}

while ($count > 0 or $maxed > 0) {
  if ($elapsed > ($seconds - 180)) {
    if ($evil > 0) {
      if (int(rand(5)) == 0) {
        $hard_max += int(random_normal(1,10,2));
        $hard_min += int(random_normal(1,10,2));
        $evil--;
      }
    }
    $max = $hard_max;
    if ($count > 0 and int(rand($count)) == 0) {
      $direction = 'up';
    }
    $count--;
    if ($elapsed > $seconds) {
      $count -= int(rand(2));
      $count += int(rand(2));
    } else {
      $count -= int(rand(2) + rand(2) + rand(2));
      $count += int(rand(2) + rand(2) + rand(2));
    }

    if ($count < -2) {
      $count = 1;
    }

    if ($count > $max_count) {
      $count = $max_count;
    }
  }

  #my $percent = ($pace - $min) / ($max - $min) * 100;
  my $percent = ($pace - $hard_min) / ($hard_max - $hard_min);

  if (int(rand(100)) + 1 > ($percent * 100)) {
    if (int(rand(3)) == 0) {
      $direction = 'up';
    }
  }

  if (int(rand(100)) + 1 > ((1 - $percent) * 100)) {
    if (int(rand(4)) == 0) {
      $direction = 'down';
    }
  }

  if ($pace >= $max) {
    $direction = 'down';
    $max += int(random_normal(1,15,2));
    if ($max >= $hard_max) {
      $max = $hard_max;
    }
    $maxed--;
  }

  if ($pace <= $min) {
    $direction = 'up';
    $min -= int(random_normal(1,15,2));
    if ($min <= $hard_min) {
      $min = $hard_min;
    }
  }

  # Initialize $new_pace
  my $new_pace  = $pace;
  my $period    = int(random_normal(1,20,2));

  my $delta;
  my $build;
  my $steady;

  if ($direction eq 'up') {
    # Smaller steps as pace increases
    my $weight = int(20 * (1 - $percent)) + 1;
    $delta = int(random_normal(1,$weight,$weight / 5));
    $new_pace = $pace + $delta;
    if ($new_pace > $max) {
      $new_pace = $max;
    }
  } else {
    # Smaller steps as pace decreases
    my $weight = int(20 * $percent) + 1;
    $delta = int(random_normal(1,$weight,$weight / 5));
    $new_pace = $pace - $delta;
    if ($new_pace < $min) {
      $new_pace = $min;
    }
  }

  if ($pace < $max and int(rand(($percent * 10 + 1) * 3)) == 0) {
    $new_pace = $max;
  }

  if ($pace > $min and int(rand(((1-$percent) * 10 + 1) * 3)) == 0) {
    $new_pace = $min;
  }

  if ($new_pace == $max) {
    if ($pace < ($max - 1) and int(rand(4)) == 0) {
      # Randomly prevent pace from hitting max, this time
      $new_pace = $pace + int(rand($max - $pace));
      if (int(rand(3)) == 0) {
        $direction = 'down';
      }
    } else {
      $period *= 1.5;
    }
  }

  if ($new_pace == $min) {
    if ($pace > ($min + 1) and int(rand(4)) == 0) {
      # Randomly prevent pace from hitting min, this time
      $new_pace = $pace - int(rand($pace - $min));
      if (int(rand(3)) == 0) {
        $direction = 'up';
      }
    } else {
      $period *= 1.5;
    }
  }

  my $avg = ($pace + $new_pace) / 2;
  my $avg_pct = ($avg - $hard_min) / ($hard_max - $hard_min);

  if ($direction eq 'up') {
    # Longer steady than build for high pace
    $steady = $period * $avg_pct;
    $build = $period - $steady;
  } else {
    # Longer build than steady for low pace
    $build = $period * $avg_pct;
    $steady = $period - $build;
  }
  # TODO: fix negative number issue for steady/build

  $build = int($build);
  $steady = int($steady);
  $new_pace = int($new_pace);

  my $command = "$beat_maker -s $pace -e $new_pace -p $build -S $steady";
  if (open my $pipe,'-|',"$command") {
    foreach my $line (<$pipe>) {
      if ($line =~ /# ([0-9\.]+) seconds/i) {
        $elapsed += $1;
      }
      print $line;
    }
  } else {
    print STDERR "Could not run $command: $!\n";
    exit 1;
  }
  $pace = $new_pace;
}

print "# Approximately ",sec2human($elapsed),"\n";

sub sec2human {
  my $secs = shift;
  if ($secs >= 365*24*60*60) {
    return sprintf '%.1f years', $secs/(365+*24*60*60);
  } elsif ($secs >= 24*60*60) {
    return sprintf '%.1f days', $secs/(24*60*60);
  } elsif ($secs >= 60*60) {
    return sprintf '%.1f hours', $secs/(60*60);
  } elsif ($secs >= 60) {
    return sprintf '%.1f minutes', $secs/60;
  } else {
    return sprintf '%.1f seconds', $secs;
  }
}
