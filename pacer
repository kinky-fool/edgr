#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

srand("$$" . time);

my $beat_maker  = "$ENV{HOME}/toys/change-pace";

my $min_pace    = 95;
my $max_pace    = 185;

# The 'end zones' (in percent)
my $low_end     = 30;
my $high_end    = 80;

# Real pace and range are set further below, so max/min/end can be args
my $pace        = 0;
my $field       = 0;

my @dice        = ();

my $time        = 5;
my $extra_time  = 0;
my $min_time    = 0;
my $max_time    = 0;
my $run_time    = 0;
my $elapsed     = 0;

my $end_at_max  = 0;
my $finish_it   = 0;
my $finished    = 0;

# Amount of time (in seconds) to go from min to max / max to min
my $end_to_end  = 30;

# % chance time will be added
my $add_pct     = 23;
# % chance time will be removed
my $sub_pct     = 23;

# Number of times pace needs to hit the max or min pace
my $maxes       = 0;
my $mins        = 0;

my $fuzzify     = 1;
my $direction   = 1;
my $go_down     = 3 + plus_or_minus(2);

# Reduce chances of starting going down
if (int(rand($go_down))) {
  $go_down = 0;
}

GetOptions(
  "max=i"     => \$max_pace,
  "min=i"     => \$min_pace,
  "pace=i"    => \$pace,
  "maxes=i"   => \$maxes,
  "mins=i"    => \$mins,
  "time=f"    => \$time,
  "extra=f"   => \$extra_time,
  "add=f"     => \$add_pct,
  "sub=f"     => \$sub_pct,
  "dice=s"    => \@dice,
  "fastend=i" => \$end_at_max,
) or die("Error in args.\n");

printf "#fastend End at max: %s\n", $end_at_max;

$field = $max_pace - $min_pace;
if ($field < 0) {
  printf STDERR "\$max_pace ($max_pace) is lower than \$min_pace ($min_pace); ";
  printf STDERR "Something appears to be wrong.\n";
  exit 1;
}
# Set the pace to just outside of the low end zone
$pace = $min_pace + int($field * ($low_end / 100)) + 5;

$extra_time = $extra_time * 60;

if (@dice) {
  my $seconds = 0;
  foreach my $dice (@dice) {
    my ($count,$sides,$low,$high) = split(/:/,$dice);
    if (!$sides) {
      $sides = 6;
    }
    if (!$low) {
      $low = 0;
    }
    if (!$high) {
      $high = 0;
    }
    my @rolls = ();
    for (1 .. $count + $low + $high) {
      push(@rolls,int(rand($sides)+1));
    }
    @rolls = sort { $a <=> $b } @rolls;
    my @lows  = @rolls[0 .. $low - 1];
    my @highs = @rolls[$#rolls - $high + 1 .. $#rolls];
    my @used  = @rolls[$low .. $#rolls - $high];
    print "#dice Dice Rolls: @lows [ @used ] @highs\n";
    foreach my $spots (@used) {
      $seconds += $spots * 60;
    }
  }
  $extra_time = $seconds;
}

$min_time = $time * 60;

if ($fuzzify) {
  $min_time = fuzzy($min_time);
  $extra_time = fuzzy($extra_time);
}

$max_time = $min_time + $extra_time;
$run_time = $min_time + int($extra_time / 4);

while ($finished == 0) {
  my $percent = ($pace - $min_pace) / $field;

  # Adjust $run_time
  if ($add_pct > rand(100)) {
    $run_time += fuzzy(int($extra_time / 60 * 3));
    if ($run_time > $max_time) {
      $run_time = $max_time;
    }
  }

  if ($sub_pct > rand(100)) {
    $run_time -= fuzzy(int($extra_time / 60 * 3));
    if ($min_time > $run_time) {
      $run_time = $min_time;
    }
  }

  if ($go_down > 0) {
    $go_down--;
  } else {
    if ($percent*100 >= $high_end) {
      $direction = 1;
    } elsif ($percent*100 <= $low_end) {
      $direction = -1;
    } elsif (($elapsed / $min_time) > rand(1)) {
      $direction = 1;
    } else {
      $direction = -1;
      if (int(rand(2))) {
        $go_down = 3 + plus_or_minus(2);
      }
    }
  }

  if ($pace >= $max_pace or
      (!int(rand($max_pace - $pace)) and $finish_it <= 0)) {
    $go_down = 0;
    $direction = -1;
    if (int(rand(2))) {
      $go_down = 3 + plus_or_minus(2);
    }
  }

  if ($pace <= $min_pace or !int(rand($pace - $min_pace))) {
    $go_down = 0;
    $direction = 1;
  }

  # Lower step as pace approaches either extreme, highest at 50%
  my $step = 13;
  my @steps = (34, 21, 13, 8, 5, 3, 2, 1);
  my $step_tier = 0;
  if ($direction > 0) {
    $step_tier = sprintf "%.0f", $percent * $#steps;
  } else {
    $step_tier = sprintf "%.0f", (1 - $percent) * $#steps;
  }
  $step = $steps[$step_tier];

  if ($fuzzify) {
    $step = fuzzy($step);
  }
  $step = 1 if ($step < 1);

  # Set the new pace
  my $new_pace = $pace + ($step * $direction);

  if ($percent*100 >= $high_end and $direction < 0) {
    $new_pace = $min_pace + int($field * (fuzzy(50) / 100));
    if (!int(rand(4))) {
      $new_pace = $min_pace + int($field * fuzzy($low_end) / 100);
      $go_down = 3 + plus_or_minus(2);
    }
  }

  if ($percent*100 <= $low_end and $direction > 0) {
    $new_pace = $min_pace + int($field * (fuzzy(50) / 100));
    if (!int(rand(4)) or $finish_it > 0) {
      $new_pace = $min_pace + int($field * fuzzy($high_end) / 100);
    }
  }

  if ($pace < $max_pace and $elapsed > $min_time and
      $go_down <= 0 and $direction < 0 and !int(rand(6))) {
    $new_pace = $max_pace;
  }

  if ($new_pace >= $max_pace) {
    $new_pace = $max_pace;
    $maxes--;
  }

  if ($min_pace >= $new_pace) {
    $new_pace = $min_pace;
    $mins--;
  }

  if ($pace == $new_pace) {
    print STDERR "pace = new pace; bad math somewhere\n";
  }

  my $new_pct = ($new_pace - $min_pace) / $field;
  my $steady;
  if ($direction > 0) {
    $steady = sprintf("%.0f",$new_pct * 20);
  } else {
    $steady = sprintf("%.0f",(1 - $new_pct) * 20);
  }
  if ($fuzzify) {
    $steady = fuzzy($steady);
  }
  $steady = 1 if ($steady < 1);

  my $delta_pct = abs($new_pace - $pace) / $field;
  my $build = int($end_to_end * $delta_pct);
  if ($fuzzify) {
    $build = fuzzy($build);
  }
  $build = 1 if ($build < 1);

  if ($new_pace == $max_pace) {
    $steady = int($steady * 1.5);
    if ($finish_it > 0) {
      $end_at_max--;
      $steady *= 2;
    }
  } elsif ($finish_it > 0) {
    $steady = int($steady / 2);
    $build = int($build / 2);
  }

  my $command = "$beat_maker -s $pace -e $new_pace -p $build -S $steady";
  if (open my $pipe,'-|',"$command") {
    while (<$pipe>) {
      if ($_ =~ /^# ([0-9\.]+) seconds/) {
        $elapsed += $1;
      }
      print;
    }
    close $pipe;
  } else {
    print STDERR "Could not run $command: $!\n";
    exit 1;
  }

  # Prep for the next period
  $pace = $new_pace;

  if ($elapsed > $min_time and $end_at_max > 0) {
    $finish_it = 1;
  }

  if ($end_at_max <= 0) {
    if ($finish_it > 0 and $maxes <= 0 and $mins <= 0) {
      $finished = 1;
    }

    if ($elapsed > $max_time) {
      $finished = 1;
    }

    if ($elapsed > $run_time and $maxes <= 0 and $mins <= 0) {
      $finished = 1;
    }
  }
}

printf "#length Session Length: %s [ %s ] %s\n",
        sec2human($min_time),
        sec2human($elapsed),
        sec2human($max_time);

sub sec2human {
  my $secs = shift;
  if ($secs >= 365*24*60*60) {
    return sprintf '%.1f years', $secs/(365+*24*60*60);
  } elsif ($secs >= 24*60*60) {
    return sprintf '%.1f days', $secs/(24*60*60);
  } elsif ($secs >= 60*60) {
    return sprintf '%.1f hours', $secs/(60*60);
  } elsif ($secs >= 60) {
    return sprintf '%.1f minutes', $secs/60;
  } else {
    return sprintf '%.1f seconds', $secs;
  }
}

sub fuzzy {
  my $num   = shift;

  # Control how far to deviate from $num
  my $skew = int(rand(3))+2;
  # Lean toward 0 or 2 * $num
  my $lean = int(rand(4))+2;
  # This is not superflous; the rand($lean) below will favor this direction
  my $point = 1;
  # "Flip a coin" to determine the direction of the lean
  if (int(rand(2))) {
    $point = -1;
  }

  my $result = $num;

  for (1 .. int($num)) {
    if (!int(rand($skew))) {
      if (int(rand($lean))) {
        $result += $point;
      } else {
        $result += ($point * -1);
      }
    }
  }
  return $result;
}

sub plus_or_minus {
  my $num     = shift;

  my $result  = 0;

  for (1 .. int($num)) {
    if (int(rand(2))) {
      $result += int(rand(2));
    } else {
      $result -= int(rand(2));
    }
  }

  return $result;
}
