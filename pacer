#!/usr/bin/perl

use strict;
use warnings;

use Math::Random;
use Getopt::Long;

srand("$$" . time);

my $beat_maker  = "$ENV{HOME}/toys/change-pace";

my $min_pace    = 95;
my $max_pace    = 185;

# The 'end zones' (in percent)
my $low_end     = 30;
my $high_end    = 80;

# Real pace and range are set further below, so max/min/end can be args
my $pace        = 0;
my $field       = 0;

my @dice        = ();

my $time        = 15;
my $extra_time  = 5;
my $min_time    = 0;
my $max_time    = 0;
my $run_time    = 0;
my $elapsed     = 0;

my $base_step   = 15;
my $avg_steady  = 5;

my $end_at_max  = 1;
my $finish_it   = 0;
my $finished    = 0;

# Amount of time (in seconds) to go from min to max / max to min
my $end_to_end  = 20;

# % chance time will be added
my $add_pct     = 30;
# % chance time will be removed
my $sub_pct     = 15;

# Number of times pace needs to hit the max or min pace
my $maxes       = 0;
my $mins        = 0;

my $fuzzify     = 1;
my $relief      = 0;
my $direction   = 1;
my $streak      = fuzzy(5);

# Reduce chances of starting with a streak going
if (int(rand($streak))) {
  $streak = 0;
}

GetOptions(
  "max=i"     => \$max_pace,
  "min=i"     => \$min_pace,
  "pace=i"    => \$pace,
  "maxes=i"   => \$maxes,
  "mins=i"    => \$mins,
  "time=f"    => \$time,
  "extra=f"   => \$extra_time,
  "add=f"     => \$add_pct,
  "sub=f"     => \$sub_pct,
  "dice=s"    => \@dice,
) or die("Error in args.\n");


$min_time = $time * 60;
$field = $max_pace - $min_pace;
if ($field < 0) {
  printf STDERR "\$max_pace ($max_pace) is lower than \$min_pace ($min_pace); ";
  printf STDERR "Something appears to be wrong.\n";
  exit 1;
}
# Set the pace to just outside of the low end zone
$pace = $min_pace + int($field * ($low_end / 100)) + 5;

if (@dice) {
  my $seconds = 0;
  foreach my $dice (@dice) {
    my ($count,$sides,$low,$high) = split(/:/,$dice);
    if (!$sides) {
      $sides = 6;
    }
    if (!$low) {
      $low = 0;
    }
    if (!$high) {
      $high = 0;
    }
    my @rolls = ();
    for (1 .. $count + $low + $high) {
      push(@rolls,int(rand($sides)+1));
    }
    print STDERR "Dice Rolled: @rolls\n";
    my @used = ();
    # Discard $low lowest dice
    @used = (sort { $a <=> $b } @rolls)[$low .. $#rolls];
    # Discard $high highest dice
    @used = (sort { $b <=> $a } @used)[$high .. $#used];
    foreach my $spots (@used) {
      $seconds += $spots * 60;
    }
    print STDERR "Dice Chosen: @used\n";
  }
  $min_time = $seconds;
}

$max_time = $min_time + ($extra_time * 60);
$run_time = $min_time;

while ($finished == 0) {
  my $percent = ($pace - $min_pace) / $field;

  # Adjust $run_time
  if ($add_pct > rand(100)) {
    $run_time += fuzzy(int($extra_time * 3));
    if ($run_time > $max_time) {
      $run_time = $max_time;
    }
  }

  if ($sub_pct > rand(100)) {
    $run_time -= fuzzy(int($extra_time * 3));
    if ($min_time > $run_time) {
      $run_time = $min_time;
    }
  }

  if ($streak > 0) {
    $streak--;
  } else {
    if (!int(rand(2))) {
      $direction *= -1;
    }
    if (!int(rand(4))) {
      # Start a streak
      $streak = fuzzy(3);
      if ($percent >= $high_end) {
        $direction = -1;
      } elsif ($low_end >= $percent) {
        $direction = 1;
      }
    }
  }

  my $step = int($base_step * $percent);

  if ($direction < 0) {
    $step = $base_step - $step;
  }

  $step = $step + fuzzy(5);

  if ($fuzzify) {
    $step = fuzzy($step);
  }

  # Set the new pace
  my $new_pace = $pace + ($step * $direction);

  if ($percent*100 >= $high_end) {
    if ($streak <= 0) {
      # Not done yet!
      $direction = 1;
      # Take smaller steps
      $new_pace = $pace + int($step / 2);
    }
    my $close = $max_pace - $pace;
    if ($close > 0) {
      if ($new_pace >= $max_pace) {
        if (!int(rand($close))) {
          $new_pace = $pace + int(rand($close-1)) + 1;
        } else {
          $new_pace = $max_pace;
        }
      }
    }
    # Chance that pace decreases to ~half closer to $max_pace
    if (!int(rand($close)) or $close <= 0) {
      $streak = 0;
      $new_pace = $min_pace + int($field * (fuzzy(50) / 100));
    }
  } elsif ($low_end >= $percent*100) {
    my $close = $pace - $min_pace;
    if ($close > 0) {
      if ($streak <= 0) {
        $direction = -1;
        # Take larger steps
        $new_pace = $pace - int($step * 1.25);
      }
      if ($min_pace > $new_pace) {
        $new_pace = $min_pace;
      }
    }
    # Chance that pace increases to ~half closer to $min_pace
    if (!int(rand($close)) or $close <= 0) {
      $streak = 0;
      $new_pace = $min_pace + int($field * (fuzzy(50) / 100));
    }
    if (!int(rand(12)) or $finish_it > 0) {
      $new_pace = $max_pace - ($step / 2);
    }
  }

  $new_pace = int($new_pace);

  if ($pace < $max_pace and $elapsed > $min_time
        and !$relief and !int(rand(fuzzy(3)))) {
    $new_pace = $max_pace;
    $relief = fuzzy(4);
  }

  if ($new_pace > $max_pace) {
    $new_pace = $max_pace;
  }

  if ($min_pace > $new_pace) {
    $new_pace = $min_pace;
  }

  if ($pace == $new_pace) {
    print STDERR "pace = new pace; bad math somewhere\n";
  }

  my $steady = $avg_steady;

  if ($percent > 50 and $direction > 0) {
    $steady = $steady + int(2 * $steady * ($percent - 50) / 50);
  } else {
    $steady = $steady + int(2 * $steady * (50 - $percent) / 50);
  }

  if ($fuzzify) {
    $steady = fuzzy($steady);
  }

  my $delta_pct = abs($new_pace - $pace) / $field;
  my $build = int($end_to_end * $delta_pct);

  if ($fuzzify) {
    $build = fuzzy($build)+1;
  }

  if ($finish_it > 0) {
    if ($low_end >= $percent*100) {
      $build = int($build * 1.5);
    }

    if ($new_pace == $max_pace) {
      $steady = int($steady * 2);
      $finished = 1;
    }
  }

  my $command = "$beat_maker -s $pace -e $new_pace -p $build -S $steady";
  if (open my $pipe,'-|',"$command") {
    foreach my $line (<$pipe>) {
      if ($line =~ /# ([0-9\.]+) seconds/i) {
        $elapsed += $1;
      }
      print $line;
    }
  } else {
    print STDERR "Could not run $command: $!\n";
    exit 1;
  }

  # Prep for the next period
  $pace = $new_pace;

  if ($pace >= $max_pace) {
    $direction = -1;
    $maxes--;
  }

  if ($min_pace >= $pace) {
    $direction = 1;
    $mins--;
  }

  if ($elapsed > $min_time) {
    if ($relief > 0) {
      $relief--;
      $direction = -1;
    }

    if ($elapsed > $max_time) {
      $finished = 1;
    }

    if ($elapsed > $run_time and $maxes <= 0 and $mins <= 0) {
      if ($end_at_max > 0) {
        $finish_it  = 1;
      } else {
        $finished = 1;
      }
    }
  }
}

print STDERR "Approximately ",sec2human($elapsed),"\n";

sub sec2human {
  my $secs = shift;
  if ($secs >= 365*24*60*60) {
    return sprintf '%.1f years', $secs/(365+*24*60*60);
  } elsif ($secs >= 24*60*60) {
    return sprintf '%.1f days', $secs/(24*60*60);
  } elsif ($secs >= 60*60) {
    return sprintf '%.1f hours', $secs/(60*60);
  } elsif ($secs >= 60) {
    return sprintf '%.1f minutes', $secs/60;
  } else {
    return sprintf '%.1f seconds', $secs;
  }
}

sub fuzzy {
  my $num   = shift;

  # Control how far to deviate from $num
  my $skew = int(rand(3))+2;
  # Lean toward 0 or 2 * $num
  my $lean = int(rand(4))+2;
  # This is not superflous; the rand($lean) below will favor this direction
  my $point = 1;
  # "Flip a coin" to determine the direction of the lean
  if (int(rand(2))) {
    $point = -1;
  }

  my $result = $num;

  for (1 .. int($num)) {
    if (!int(rand($skew))) {
      if (int(rand($lean))) {
        $result += $point;
      } else {
        $result += ($point * -1);
      }
    }
  }
  return $result;
}
