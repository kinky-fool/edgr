#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

srand("$$" . time);

my $beat_maker  = "$ENV{HOME}/toys/change-pace";

my $min_pace    = 95;
my $max_pace    = 185;

# The 'end zones' (in percent)
my $low_end     = 30;
my $high_end    = 80;

# Real pace and range are set further below, so max/min/end can be args
my $pace        = 0;
my $field       = 0;

my @dice        = ();

my $time        = 15;
my $extra_time  = 5;
my $min_time    = 0;
my $max_time    = 0;
my $run_time    = 0;
my $elapsed     = 0;

my $base_step   = 15;
my $base_steady = 3;

my $end_at_max  = 1;
my $dice_roll   = int(rand(6)) + int(rand(6)) + 2;
if ($dice_roll == 7) {
  $end_at_max = 0;
}
if ($dice_roll == 2) {
  $end_at_max = 3;
}

my $finish_it   = 0;
my $finished    = 0;

# Amount of time (in seconds) to go from min to max / max to min
my $end_to_end  = 20;

# % chance time will be added
my $add_pct     = 23;
# % chance time will be removed
my $sub_pct     = 20;

# Number of times pace needs to hit the max or min pace
my $maxes       = 0;
my $mins        = 0;

my $fuzzify     = 1;
my $direction   = 1;
my $streak      = fuzzy(5);

# Reduce chances of starting with a streak going
if (int(rand($streak))) {
  $streak = 0;
}

GetOptions(
  "max=i"     => \$max_pace,
  "min=i"     => \$min_pace,
  "pace=i"    => \$pace,
  "maxes=i"   => \$maxes,
  "mins=i"    => \$mins,
  "time=f"    => \$time,
  "extra=f"   => \$extra_time,
  "add=f"     => \$add_pct,
  "sub=f"     => \$sub_pct,
  "dice=s"    => \@dice,
  "fastend=i" => \$end_at_max,
) or die("Error in args.\n");

printf "#fastend End at max: %s\n", $end_at_max;

$min_time = $time * 60;
$field = $max_pace - $min_pace;
if ($field < 0) {
  printf STDERR "\$max_pace ($max_pace) is lower than \$min_pace ($min_pace); ";
  printf STDERR "Something appears to be wrong.\n";
  exit 1;
}
# Set the pace to just outside of the low end zone
$pace = $min_pace + int($field * ($low_end / 100)) + 5;

if (@dice) {
  my $seconds = 0;
  foreach my $dice (@dice) {
    my ($count,$sides,$low,$high) = split(/:/,$dice);
    if (!$sides) {
      $sides = 6;
    }
    if (!$low) {
      $low = 0;
    }
    if (!$high) {
      $high = 0;
    }
    my @rolls = ();
    for (1 .. $count + $low + $high) {
      push(@rolls,int(rand($sides)+1));
    }
    @rolls = sort { $a <=> $b } @rolls;
    my @lows  = @rolls[0 .. $low - 1];
    my @highs = @rolls[$#rolls - $high + 1 .. $#rolls];
    my @used  = @rolls[$low .. $#rolls - $high];
    print "#dice Dice Rolls: @lows [ @used ] @highs\n";
    foreach my $spots (@used) {
      $seconds += $spots * 60;
    }
  }
  $min_time = $seconds;
}

$max_time = $min_time + ($extra_time * 60);
$run_time = $min_time;

while ($finished == 0) {
  my $percent = ($pace - $min_pace) / $field;

  # Adjust $run_time
  if ($add_pct > rand(100)) {
    $run_time += fuzzy(int($extra_time * 3));
    if ($run_time > $max_time) {
      $run_time = $max_time;
    }
  }

  if ($sub_pct > rand(100)) {
    $run_time -= fuzzy(int($extra_time * 3));
    if ($min_time > $run_time) {
      $run_time = $min_time;
    }
  }

  if ($streak > 0) {
    $streak--;
  } else {
    if (!int(rand(2))) {
      $direction *= -1;
    }
    if (!int(rand(4))) {
      # Start a streak
      $streak = fuzzy(3);
      if ($percent*100 >= $high_end) {
        $direction = -1;
      } elsif ($low_end >= $percent*100) {
        $direction = 1;
      }
    }
  }

  my $step = int($base_step * $percent);

  if ($direction < 0) {
    $step = $base_step - $step;
  }

  $step = $step + fuzzy(3) + 1;

  if ($fuzzify) {
    $step = fuzzy($step) + 1;
  }

  # Set the new pace
  my $new_pace = $pace + ($step * $direction);

  if ($percent*100 >= $high_end and $direction > 0) {
    if ($streak <= 0) {
      # Not done yet!
      $direction = 1;
      if ($step > 1) {
        # Take smaller steps
        $new_pace = $pace + int($step / 2);
      }
    }
    my $close = $max_pace - $pace;
    if ($close > 0) {
      if ($new_pace >= $max_pace) {
        if (!int(rand($close))) {
          $new_pace = $pace + int(rand($close-1)) + 1;
        } else {
          $new_pace = $max_pace;
        }
      }
    }
    # Chance that pace decreases to ~half closer to $max_pace
    if (!int(rand($close)) or $close <= 0) {
      $streak = 0;
      $new_pace = $min_pace + int($field * (fuzzy(50) / 100));
    }
  } elsif ($low_end >= $percent*100 and $direction < 0) {
    my $close = $pace - $min_pace;
    if ($close > 0) {
      if ($streak <= 0) {
        $direction = -1;
        # Take larger steps
        $new_pace = $pace - int($step * 1.25);
      }
    }
    # Chance that pace increases to ~half closer to $min_pace
    if (!int(rand($close)) or $close <= 0) {
      $streak = 0;
      $new_pace = $min_pace + int($field * (fuzzy(50) / 100));
    }
    if (!int(rand(12)) or $finish_it > 0) {
      $new_pace = $max_pace - int($step / 2);
    }
  }

  if ($pace < $max_pace and $elapsed > $min_time
        and $streak <= 0 and $direction < 0 and !int(rand(6))) {
    $new_pace = $max_pace;
    if (!int(rand(2))) {
      $direction = -1;
      $streak = fuzzy(3)+1;
    }
  }

  if ($new_pace >= $max_pace) {
    $new_pace = $max_pace;
    $direction = -1;
    $maxes--;
  }

  if ($min_pace >= $new_pace) {
    $new_pace = $min_pace;
    $direction = 1;
    $mins--;
  }

  if ($pace == $new_pace) {
    print STDERR "pace = new pace; bad math somewhere\n";
  }

  my $new_pct = ($new_pace - $min_pace) / $field;
  my $steady = $base_steady + int((abs(0.5 - $new_pct) * 10) * $base_steady);
  if ($fuzzify) {
    $steady = fuzzy($steady)+1;
  }

  my $delta_pct = abs($new_pace - $pace) / $field;
  my $build = int($end_to_end * $delta_pct);
  if ($fuzzify) {
    $build = fuzzy($build)+1;
  }

  if ($new_pace == $max_pace) {
    $steady = int($steady * 1.5);
    if ($finish_it > 0) {
      $end_at_max--;
      $steady *= 2;
    }
  }

  my $command = "$beat_maker -s $pace -e $new_pace -p $build -S $steady";
  if (open my $pipe,'-|',"$command") {
    while (<$pipe>) {
      if ($_ =~ /^# ([0-9\.]+) seconds/) {
        $elapsed += $1;
      }
      print;
    }
    close $pipe;
  } else {
    print STDERR "Could not run $command: $!\n";
    exit 1;
  }

  # Prep for the next period
  $pace = $new_pace;

  if ($elapsed > $max_time or
     ($elapsed > $run_time and $maxes <= 0 and $mins <= 0)) {
    if ($end_at_max > 0) {
      $finish_it  = 1;
    } else {
      $finished = 1;
    }
  }
}

printf "#length Session Length: %s [ %s ] %s\n",
        sec2human($min_time),
        sec2human($elapsed),
        sec2human($max_time);

sub sec2human {
  my $secs = shift;
  if ($secs >= 365*24*60*60) {
    return sprintf '%.1f years', $secs/(365+*24*60*60);
  } elsif ($secs >= 24*60*60) {
    return sprintf '%.1f days', $secs/(24*60*60);
  } elsif ($secs >= 60*60) {
    return sprintf '%.1f hours', $secs/(60*60);
  } elsif ($secs >= 60) {
    return sprintf '%.1f minutes', $secs/60;
  } else {
    return sprintf '%.1f seconds', $secs;
  }
}

sub fuzzy {
  my $num   = shift;

  # Control how far to deviate from $num
  my $skew = int(rand(3))+2;
  # Lean toward 0 or 2 * $num
  my $lean = int(rand(4))+2;
  # This is not superflous; the rand($lean) below will favor this direction
  my $point = 1;
  # "Flip a coin" to determine the direction of the lean
  if (int(rand(2))) {
    $point = -1;
  }

  my $result = $num;

  for (1 .. int($num)) {
    if (!int(rand($skew))) {
      if (int(rand($lean))) {
        $result += $point;
      } else {
        $result += ($point * -1);
      }
    }
  }
  return $result;
}
