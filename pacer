#!/usr/bin/perl

use strict;
use warnings;

use Math::Random;
use Getopt::Long;

srand("$$" . time);

my $beat_maker  = "$ENV{HOME}/toys/change-pace";

my $pace        = 0;
my $hard_max    = 180;
my $hard_min    = 80;
my $base_max    = $hard_min + ($hard_max - $hard_min) * 7 / 10;
my $base_min    = $hard_min + ($hard_max - $hard_min) * 3 / 10;
my $min         = $base_min;
my $max         = $base_max;

my @dice        = ();

my $time        = 15;
my $extra_time  = 5;
my $min_time    = 0;
my $max_time    = 0;
my $elapsed     = 0;

my $finished    = 0;

# 1 in X chance that the program will end; used after min_time is met
my $chance      = 8;
# Times that hard_max can be increased
my $evil        = 3;
# Number of times pace needs to hit the max or min pace
my $maxes       = 0;
my $mins        = 0;

my $direction   = 1;
my $streak      = int(random_normal(1,5,1));
# Reduce chances of starting with a streak going
if (int(rand($streak))) {
  $streak = 0;
}

GetOptions(
  "hardmax=i" => \$hard_max,
  "hardmin=i" => \$hard_min,
  "max=i"     => \$max,
  "min=i"     => \$min,
  "pace=i"    => \$pace,
  "evil=i"    => \$evil,
  "maxes=i"   => \$maxes,
  "mins=i"    => \$mins,
  "time=f"    => \$time,
  "extra=f"   => \$extra_time,
  "chance=i"  => \$chance,
  "dice=s"    => \@dice,
) or die("Error in args.\n");


if ($pace == 0) {
  $pace = int(rand($max - $min) / 3) + $min;
}

$min_time = $time * 60;

if (@dice) {
  my $seconds = 0;
  foreach my $dice (@dice) {
    my ($count,$sides,$low,$high) = split(/:/,$dice);
    if (!$sides) {
      $sides = 6;
    }
    if (!$low) {
      $low = 0;
    }
    if (!$high) {
      $high = 0;
    }
    my @rolls = ();
    for (1 .. $count + $low + $high) {
      push(@rolls,int(rand($sides)+1));
    }
    print STDERR "Dice Rolled: @rolls\n";
    my @used = ();
    # Discard $low lowest dice
    @used = (sort { $a <=> $b } @rolls)[$low .. $#rolls];
    # Discard $high highest dice
    @used = (sort { $b <=> $a } @used)[$high .. $#used];
    foreach my $spots (@used) {
      $seconds += $spots * 60;
    }
    print STDERR "Dice Chosen: @used\n";
  }
  $min_time = $seconds;
}

$max_time = $min_time + ($extra_time * 60);

while ($finished == 0) {
  # Set max/min for the current state, otherwise percent calculations get bad
  my $temp_max = $max;
  my $temp_min = $min;

  if ($pace > $temp_max) {
    $temp_max = $pace;
  }

  if ($pace < $temp_min) {
    $temp_min = $pace;
  }

  my $percent = ($pace - $temp_min) / ($temp_max - $temp_min);

  if ($streak <= 0 and !int(rand(4))) {
    # Reverse direction
    $streak = 0;
    $direction *= -1;
    $streak = int(random_normal(1,5,1));
  }

  $streak--;

  if ($pace >= $max) {
    $direction = -1;
    $streak = 0;
  }

  if ($pace <= $min) {
    $direction = 1;
    $streak = 0;
  }

  my $delta_base = 15;
  my $weight = $delta_base * $percent;
  if ($direction < 0) {
    $weight = $delta_base - $weight;
  }
  $weight = $weight + 5;
  my $delta = int(random_normal(1,$weight,$weight / 5));
  my $new_pace = $pace + ($delta * $direction);

  my $period    = int(random_normal(1,20,2));

  if ($direction > 0) {
    if ($pace < $max and !int(rand(($percent * 10 + 1) * 3))) {
      $new_pace = $max;
    }
  } else {
    if ($pace > $min and !int(rand(((1-$percent) * 10 + 1) * 3))) {
      $new_pace = $min;
    }
  }

  # Calculations for next iteration below here:
  if ($new_pace >= $max) {
    # Chance that pace doesn't max out, this time.
    if ($pace < ($max - 1)) {
      if (int(rand(3)) or $streak > 0) {
        # Prevent maxing out; randomly or if on a streak
        $new_pace = $pace + int(rand($max - $pace)) + 1;
        if (!int(rand(4))) {
          # 25% chance of changing direction
          $direction = -1;
        }
      }
    }

    # Re-check new_pace
    if ($new_pace >= $max) {
      $new_pace = $max;
      $maxes--;
      $period *= 1.5;
    }

    # Increase maximum pace
    $max += int(random_normal(1,15,2));
    if ($max > $hard_max) {
      $max = $hard_max;
    }
  }

  if ($new_pace <= $min) {
    # Chance that pace doesn't hit bottom, this time.
    if ($pace > ($min + 1)) {
      if (int(rand(3)) or $streak > 0) {
        # Prevent minning out; randomly or if on a streak
        my $temp = int(rand(abs($pace - $min)))+1;
        $new_pace = $pace - (int(rand($pace - $min)) + 1);
        if (!int(rand(4))) {
          # 25% chance of changing direction
          $direction = 1;
        }
      }
    }

    # Re-check new_pace
    if ($new_pace <= $min) {
      $new_pace = $min;
      $mins--;
      $period *= 1.5;
    }

    # Decrease the minimum
    $min -= int(random_normal(1,15,2));
    if ($min < $hard_min) {
      $min = $hard_min;
    }

    if ($new_pace < $min) {
      $new_pace = $min;
    }
  }

  my $build;
  my $steady;

  my $avg = ($pace + $new_pace) / 2;
  my $avg_pct = ($avg - $temp_min) / ($temp_max - $temp_min);

  if ($direction > 0) {
    # Longer steady than build for high pace
    $steady = int($period * $avg_pct);
    $build = int($period - $steady);
  } else {
    # Longer build than steady for low pace
    $build = int($period * $avg_pct);
    $steady = int($period - $build);
  }

  my $command = "$beat_maker -s $pace -e $new_pace -p $build -S $steady";
  if (open my $pipe,'-|',"$command") {
    foreach my $line (<$pipe>) {
      if ($line =~ /# ([0-9\.]+) seconds/i) {
        $elapsed += $1;
      }
      print $line;
    }
  } else {
    print STDERR "Could not run $command: $!\n";
    exit 1;
  }

  $pace = $new_pace;

  if ($elapsed > $min_time) {
    if ($evil > 0) {
      if (int(rand(5)) == 0) {
        $hard_max += int(random_normal(1,10,2));
        $hard_min += int(random_normal(1,10,2));
        $evil--;
      }
    }
    $max = $hard_max;

    if ($elapsed > $max_time) {
      $finished = 1;
    }

    if (!int(rand($chance))) {
      if (!$maxes and !$mins) {
        $finished = 1;
      }
    }
  }
}

print STDERR "Approximately ",sec2human($elapsed),"\n";

sub sec2human {
  my $secs = shift;
  if ($secs >= 365*24*60*60) {
    return sprintf '%.1f years', $secs/(365+*24*60*60);
  } elsif ($secs >= 24*60*60) {
    return sprintf '%.1f days', $secs/(24*60*60);
  } elsif ($secs >= 60*60) {
    return sprintf '%.1f hours', $secs/(60*60);
  } elsif ($secs >= 60) {
    return sprintf '%.1f minutes', $secs/60;
  } else {
    return sprintf '%.1f seconds', $secs;
  }
}
