#!/usr/bin/env python3

import threading
import random
import time
import sys
import os

from playsound import playsound

home_dir = os.environ['HOME']

tick_sound = f'{home_dir}/lib/audio/tick.wav'
tock_sound = f'{home_dir}/lib/audio/tock.wav'

# min / max time per step of the journey between waypoints
journey_secs_min = 5
journey_secs_max = 15

# min / max time at each waypoint
waypoint_secs_min = 15
waypoint_secs_max = 30

# step size for slowing down
step_slow     = 0.005

# step size for speeding up
step_fast     = 0.001

# default length of stroke -- down*(stroke_time pause)*up
stroke_time = 0.34

# default speed-step waypoints for strokes
waypoints = [
  0.18,
  0.20,
  0.22,
  0.24,
  0.28,
  0.34,
  0.42,
  0.50,
  0.65,
]

def main():
  session = beater()
  session.start()

def play_sound(file=None, blocking=False):
  import sys
  import threading
  from playsound import playsound

  if file == None:
    print("filename not provided")
    sys.exit(1)

  if not os.path.isfile(file):
    print(f"filename provided ('{filename}') is not a file")
    sys.exit(1)

  if blocking:
    playsound(file)

  else:
    sound_thread = threading.Thread(target=playsound, args=(file,))
    sound_thread.start()

  return


class beater(object):

  def __init__(self, tock=False):
    import signal

    # handle ctrl-c gracefully with sig_handler()
    signal.signal(signal.SIGINT, self.sig_handler)

    # whether to 'tock' or not -- 'up' stroke
    self.tock               = False

    self.waypoints          = waypoints.copy()
    self.tick_sound         = tick_sound
    self.tock_sound         = tock_sound
    self.step_slow          = step_slow
    self.step_fast          = step_fast
    self.stroke_time        = stroke_time
    self.journey_secs_min   = journey_secs_min
    self.journey_secs_max   = journey_secs_max
    self.waypoint_secs_min  = waypoint_secs_min
    self.waypoint_secs_max  = waypoint_secs_max

    # flag if session / stroking is done (ctrl c or time-out)
    self.done               = False

    if tock:
      self.tock = True

    if waypoints:
      self.waypoints = waypoints.copy()

    if tick_sound:
      self.tick_sound = tick_sound

    if tock_sound:
      self.tock_sound = tock_sound

    if step_slow:
      self.step_slow = step_slow

    if step_fast:
      self.step_fast = step_fast

    if stroke_time:
      self.stoke_time = stroke_time

    # set the initial pace
    self.stroke_pace = random.choice(self.waypoints[1:-1])

  # handle ctrl-c with this function
  def sig_handler(self, *args):
    import sys

    self.done = True
    sys.exit(1)

  # create and start the ticker thread
  def start(self):
    import threading
    thread = threading.Thread(target = self.__ticker)
    thread.start()

    while True:
      self.change_pace(random.choice(self.waypoints[1:-1]))
      time.sleep(random.uniform(self.waypoint_secs_min,
                                self.waypoint_secs_max))
      if random.randint(0,7) == 0:
        if random.randint(0,2) == 0:
          self.change_pace(self.waypoints[-1])

        else:
          self.change_pace(self.waypoints[0])

        time.sleep(random.uniform(self.waypoint_secs_max,
                                  self.waypoint_secs_max * 3))

      # end loop if aborted
      if self.done == True:
        return

  def change_pace(self, pace_new=None):
    if isinstance(pace_new, int) or isinstance(pace_new, float):

      pace_cur = self.get_pace()

      # if new pace is larger than current pace, we're getting slower
      if pace_new > pace_cur:
        while pace_new > pace_cur:
          self.set_pace(pace_cur + self.step_slow)
          time.sleep(random.uniform(self.journey_secs_min,
                                    self.journey_secs_max))
          pace_cur = self.get_pace()
      else:
        while pace_cur > pace_new:
          self.set_pace(pace_cur - self.step_fast)
          time.sleep(random.uniform(self.journey_secs_min,
                                    self.journey_secs_max))
          pace_cur = self.get_pace()


  # return the current stroke pace
  def get_pace(self):
    return self.stroke_pace

  # set the stroke pace
  def set_pace(self, pace_new=None):
    if isinstance(pace_new, int) or isinstance(pace_new, float):
      self.stroke_pace = pace_new

  def __ticker(self):
    while True:
      play_sound(self.tick_sound)

      time.sleep(self.stroke_time)

      if self.tock:
        play_sound(self.tock_sound)

      time.sleep(self.get_pace())

      # end loop if aborted
      if self.done == True:
        return

if __name__ == '__main__':
  main()
