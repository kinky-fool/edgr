#!/usr/bin/env python3

import time
import random
from playsound import playsound
import os
import argparse

from signal import signal, SIGINT
from sys import exit
import threading

home_dir = os.environ['HOME']
audio_dir = f'{home_dir}/lib/audio'

# Initial max seconds to count for a successful edge; if an edge is reached
# within edge_time_max, it is successful. If edge_time_max becomes the new
# shorter time, unless it is less than edge_time_maxmin.
edge_time_max = 120

# Minimum seconds that edge_time_max can be reduced to
edge_time_maxmin = 30

# Number of dice, sides and chosen dice for selecting edges
# For example; 4 sides, 3 count, 2 pick you roll:
# 3 2 3 - 3 and 3 are chosen, they match so 2 is added as well
# 4 2 1 - 4 and 2 are chosen, 1 is ignored.
edge_dice_sides = 4
edge_dice_count = 3
edge_dice_pick  = 2

# Number of dice, sides and chosen dice for number of ball slaps
# when / if ball slapping is activated
slap_dice_sides  = 4
slap_dice_count  = 3
slap_dice_pick   = 2

# When starting a session, how long to stroke before the first edging
start_stroke_min = 60
start_stroke_max = 300

# After normal stroke time, if there are delays, a laugh is played
# and more time for stroking before edging is added.
extra_stroke_min = 10
extra_stroke_max = 40

# Seconds in between edges, hands off cock for this time.
cooldown_min = 10
cooldown_max = 30

# Seconds before edge_time_max that counts as a 'close call'
close_call = 5

slap_die_sides  = 20
slap_die        = {}

green_die_sides = 20
green_die       = {}

parser = argparse.ArgumentParser()
parser.add_argument(
  '--green',
  action='store_true',
  help='Enable green light'
)

parser.add_argument(
  '--noslaps',
  action='store_true',
  help='Disable slap instructions'
)

parser.add_argument(
  '-c', '--cruel',
  action='count',
  help='More edges. More slapping. Can be used multiple times.'
)

parser.add_argument(
  '--edges',
  default=0,
  type=int,
  help='Specify the number of edges'
)

args = parser.parse_args()

green = 0
if args.green == 1:
  if random.randint(0, 20) != 0:
    green = 1
    edge_dice_sides += 1
    edge_dice_count += 1
    slap_dice_pick += 1
    slap_dice_count += 2

noslaps = 0
if args.noslaps == 1:
  noslaps = 1
  edge_dice_pick += 1
  edge_dice_count += 2
  green_dice_sides += 10

cruel = 1
if args.cruel != None and args.cruel > 0:
  cruel = 1

  for i in range(0, args.cruel):
    options = [ 'sides', 'count', 'pick' ]
    for j in range(0, random.randint(2, 3)):
      opt = random.choice(options)
      modifier = random.randint(0, 1) + random.randint(0, 2)
      if opt == 'sides':
        if random.randint(0, 1) == 0:
          slap_dice_sides += modifier
        else:
          edge_dice_sides += modifier
      elif opt == 'count':
        if random.randint(0, 1) == 0:
          slap_dice_count += modifier
        else:
          edge_dice_count += modifier
      elif opt == 'pick':
        if random.randint(0, 1) == 0:
          slap_dice_pick += modifier
        else:
          edge_dice_pick += modifier

# Set here for referencing when signal caught
edges = args.edges

def main():
  global edge_time_max, edge_time_maxmin
  global slap_die
  global green_die
  global edges

  if cruel == 1:
    slap_die_sides = 15
    for i in range(0,4):
      slap_die  = die_sides_add(slap_die, slap_die_sides)

  if edges == 0:
    edges = dice_picker(edge_dice_count, edge_dice_sides, edge_dice_pick)

  slap_die  = die_sides_add(slap_die, slap_die_sides)
  green_die = die_sides_add(green_die, green_die_sides)

  print("Get ready to edge yourself.")
  play_rand_sound(f'{audio_dir}/start', 0)

  time.sleep(random.randint(start_stroke_min, start_stroke_max))

  while edges > 0:
    if edge_for_me(edge_time_maxmin, edge_time_max):
      edges -= 1
    time.sleep(5)
    slap_your_balls()
    if edges > 0:
      print("Get ready to edge, stroke yourself!")
      play_rand_sound(f'{audio_dir}/stroke', 0)

      # TODO: Figure out how to better randomize 15 - 120 favoring ~70%
      #       and make it easier to configure as 3 vars (min, max, mean?)
      prep_time = int(random.choices(
        population  = [15, 30, 45, 60, 90, 120],
        weights     = [10, 20, 40, 40, 30,  20],
        k           = 1
      )[0])

      prep_time = fuzzy_weight(15, 120, 70)

      time.sleep(prep_time)

  print("You may stop stroking your cock.")
  play_rand_sound(f'{audio_dir}/stop', 0)

def slap_your_balls():
  if die_roll(slap_die, slap_die_sides):
    time.sleep(random.randint(3, 10))
    slaps = dice_picker(slap_dice_sides, slap_dice_count, slap_dice_pick)
    for i in range(0, slaps):
      time.sleep(random.randint(2, 14))
      play_rand_sound(f'{audio_dir}/hurt', 1)
    time.sleep(random.randint(2, 14))
  else:
    time.sleep(random.randint(5, 20))

def edge_for_me(edge_time_maxmin, edge_time_max):
  for foo in range(0, 5):
    if random.randint(1, 6) == 1:
      play_rand_sound(f'{audio_dir}/laughs', 0)
      time.sleep(random.randint(extra_stroke_min, extra_stroke_max))


  if die_roll(green_die, green_die_sides) and green == 1:
    print("Cum for me! (KIDDING - TESTING!)")
    play_rand_sound(f'{audio_dir}/edges', 0)
    # TODO: figure out how to have it stop after X seconds, and play a clip
    #       "hands off your cock" or something, instead of waiting for user
    #       to hit enter (like edging)
  else:
    print("Edge for me.")
    play_rand_sound(f'{audio_dir}/edges', 0)

  start = time.time()

  input("Press Enter once you get to the edge.")

  elapsed = time.time() - start

  print("Hands off your cock.")
  play_rand_sound(f'{audio_dir}/laughs', 0)

  time.sleep(random.randint(cooldown_min, cooldown_max))

  if elapsed > edge_time_max:
    print("Too slow, try again.")
    play_rand_sound(f'{audio_dir}/too-slow', 0)
    die_sides_add(slap_die, slap_die_sides)
    die_sides_sub(green_die, green_die_sides)
    die_sides_sub(green_die, green_die_sides)
    return 0
  else:
    print("Good boy.")
    play_rand_sound(f'{audio_dir}/good-boy', 0)
    die_sides_add(green_die, green_die_sides)
    die_sides_sub(slap_die, slap_die_sides)

    if elapsed > edge_time_max - close_call:
      print("That was close!")
      die_sides_sub(slap_die, slap_die_sides)
      die_sides_add(slap_die, slap_die_sides)
      die_sides_add(green_die, green_die_sides)

    if elapsed < (edge_time_max / 2):
      die_sides_add(green_die, green_die_sides)

    if elapsed < (edge_time_max / 4):
      die_sides_add(green_die, green_die_sides)

    if elapsed > 15:
      die_sides_add(slap_die, slap_die_sides)

    if elapsed > 30:
      die_sides_add(slap_die, slap_die_sides)
      die_sides_sub(green_die, green_die_sides)

    if elapsed > 60:
      die_sides_add(slap_die, slap_die_sides)
      die_sides_sub(green_die, green_die_sides)

    if elapsed > edge_time_maxmin:
      edge_time_max = elapsed

    return 1

def fuzzy_weight(minimum, maximum, favor):
  target = int(abs(maximum - minimum) * favor / 100)

  skew = 1
  if random.randint(0,2) == 0:
    skew = -1

  result = target
  for i in range(0, target):
    if random.randint(0, 3) == 0:
      result += skew
    else:
      result -= skew

  return result

def die_sides_add(die, sides):
  die[str(random.randint(1, sides))] = 1
  return die

def die_sides_sub(die, sides):
  roll = str(random.randint(1, sides))
  if roll in die:
    del die[roll]
  return die

def die_roll(die, sides):
  roll = str(random.randint(1, sides))
  if roll in die:
    return 1
  return 0

def dice_picker(count, sides, rc):
  dice = []
  for i in range(0, count):
    dice.append(random.randint(1, sides))
  dice.sort(reverse=True)
  paired = dice.count(dice[0])
  if paired == count:
    return sum(dice) * 2
  elif paired > 1:
    return sum(dice)
  else:
    return sum(dice[0:rc])

def play_rand_sound(directory, blocking):
  if os.path.isdir(directory):
    filename = ''

    while not os.path.isfile(f'{directory}/{filename}'):
      filename = random.choice(os.listdir(directory))

    mp3 = f'{directory}/{filename}'
    if blocking == 1:
      playsound(mp3)
    else:
      sound_thread = threading.Thread(target=playsound, args=(mp3,))
      sound_thread.start()
  return

def handler(signal_received, frame):
  print()
  print(f'Aborted with {edges} edges remaining.')
  exit(0)

if __name__ == '__main__':
  # Run handler() when SIGINT received
  signal(SIGINT, handler)

  main()
