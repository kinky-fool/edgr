#!/usr/bin/env python3

import time
import random
from playsound import playsound
import os
import argparse

from signal import signal, SIGINT
from sys import exit
import threading

import sqlite3

import shelve

home_dir = os.environ['HOME']
audio_dir = f'{home_dir}/lib/audio'

# Initial max seconds to count for a successful edge; if an edge is reached
# within edge_time_max, it is successful. If edge_time_max becomes the new
# shorter time, unless it is less than edge_time_maxmin.
edge_time_max = 60

# Minimum seconds that edge_time_max can be reduced to
edge_time_maxmin = 15

# When starting a session, how long to stroke before the first edging
start_stroke_min = 60
start_stroke_max = 240

# After normal stroke time, if there are delays, a laugh is played
# and more time for stroking before edging is added.
extra_stroke_min = 10
extra_stroke_max = 40

# Seconds in between edges, hands off cock for this time.
cooldown_min = 15
cooldown_max = 40

# Seconds before edge_time_max that counts as a 'close call'
close_call = 10

parser = argparse.ArgumentParser()
parser.add_argument(
  '--green',
  action='store_true',
  help='Enable green light'
)

parser.add_argument(
  '--noslaps',
  action='store_true',
  help='Disable slaps for slowness'
)

parser.add_argument(
  '-c', '--cruel',
  action='count',
  help='More edges. More slapping. Can be used multiple times.'
)

parser.add_argument(
  '--edges',
  default=0,
  type=int,
  help='Specify the number of edges'
)

parser.add_argument(
  '--extras',
  action='store_true',
  help='Add more edges based on "risk" level'
)

parser.add_argument(
  '--rounds',
  default=1,
  type=int,
  help='Number of rounds (default 1) to run.'
)

args = parser.parse_args()

green = 0
if args.green == 1:
  # Small chance a specified green light never happens
  if random.randint(0, 20) != 0:
    green = 1

extra_edges = 0

slapx = 2

dbh = sqlite3.connect(f'{home_dir}/.config/edgr.sqlite')
sth = dbh.cursor()
query = ''' select value from settings where name = ? '''
sth.execute(query,('risk',))
risk = sth.fetchone()[0]
dbh.commit()
dbh.close()

if risk > 0:
  for i in range(1, risk):
    if random.randint(0, 2) == 0:
      slapx = slapx + random.randint(1, 2)
      if random.randint(0, 2) == 0:
        extra_edges = extra_edges + random.randint(0, 1)
    else:
      extra_edges = extra_edges + random.randint(0, 2)

if args.noslaps == 1:
  slapx = 0

edges = args.edges # default is 0
if edges == 0:
  for i in range(0, args.rounds):
    edges += random.randint(3, 5)

if args.extras == 1:
  edges += extra_edges

# Set here for referencing when signal caught
edges_completed = 0
fails = 0

def main():
  global edge_time_max, edge_time_maxmin
  global edges, edges_completed
  global fails
  global dbh, sth

  dbh = sqlite3.connect(f'{home_dir}/.config/edgr.sqlite')
  sth = dbh.cursor()
  query = ''' insert into sessions (user_id,edges_start)
                values (?, ?) '''
  sth.execute(query,(1, edges))
  # Get the session id
  session_id = sth.lastrowid
  dbh.commit()

  print("Get ready to edge yourself.")
  play_rand_sound(f'{audio_dir}/start', 0)

  time.sleep(random.randint(start_stroke_min, start_stroke_max))

  while edges > 0:
    for foo in range(0, 5):
      if random.randint(1, 8) == 1:
        play_rand_sound(f'{audio_dir}/laughs', 0)
        time.sleep(random.randint(extra_stroke_min, extra_stroke_max))

    elapsed = edge_for_me()
    edges_completed += 1

    # Log the edge
    query = ''' insert into edges (session_id, to_edge, max, max_min, session)
                values (?, ?, ?, ?) '''
    sth.execute(query,(session_id, elapsed, edge_time_max, edge_time_maxmin))
    dbh.commit()

    time.sleep(random.randint(3, 10))

    print("Good boy.")
    play_rand_sound(f'{audio_dir}/good-boy', 0)

    if elapsed > edge_time_max:
      print("Too slow, try again.")
      edges += random.randint(0, 2)

      fails += 1

      if elapsed > 30:
        edges += random.randint(1, 2)
        fails += 1

      slaps = random.randint(0, slapx) + random.randint(0, fails)
      add_slaps(slaps)

    else:
      edges -= 1

      if elapsed > 30:
        slaps = random.randint(0, slapx)
        add_slaps(slaps)

      # Reduce edge window... dun dun duuuuunnnnnn!
      if elapsed > edge_time_maxmin and elapsed < edge_time_max:
        edge_time_max = elapsed

    time.sleep(random.randint(cooldown_min, cooldown_max))

    if edges > 0:
      print("Get ready to edge, stroke yourself!")
      play_rand_sound(f'{audio_dir}/stroke', 0)

      # TODO: Figure out how to better randomize 15 - 120 favoring ~70%
      #       and make it easier to configure as 3 vars (min, max, mean?)
      prep_time = int(random.choices(
        population  = [15, 30, 45, 60, 90, 120],
        weights     = [10, 20, 40, 40, 30,  20],
        k           = 1
      )[0])

      prep_time = fuzzy_weight(15, 120, 70)

      time.sleep(prep_time)

  print("You may stop stroking your cock.")
  completed_plural = 'edge' if edges_completed == 1 else 'edges'
  print(f'You completed {edges_completed} {completed_plural} this session.')
  play_rand_sound(f'{audio_dir}/stop', 0)

  dbh.close()

def add_slaps(slaps):
  query = """ update settings set value = value + ? where name = ? """
  sth.execute(query,(slaps, 'slaps'))
  dbh.commit()

def edge_for_me():
  if green == 1 and random.randint(0,42) == 42:
    print("Cum for me!")
    time.sleep(random.randint(3,6))
    print("Kidding!")
    play_rand_sound(f'{audio_dir}/edges', 0)
    # TODO: figure out how to have it stop after X seconds, and play a clip
    #       "hands off your cock" or something, instead of waiting for user
    #       to hit enter (like edging)
  else:
    print("Edge for me.")
    play_rand_sound(f'{audio_dir}/edges', 0)

  start = time.time()

  input("Press Enter once you get to the edge.")

  elapsed = time.time() - start

  print("Hands off your cock.")

  play_rand_sound(f'{audio_dir}/laughs', 0)

  return elapsed

def fuzzy_weight(minimum, maximum, favor):
  target = int(abs(maximum - minimum) * favor / 100)

  skew = 1
  if random.randint(0,2) == 0:
    skew = -1

  result = target
  for i in range(0, target):
    if random.randint(0, 3) == 0:
      result += skew
    else:
      result -= skew

  return result

def play_rand_sound(directory, blocking):
  if os.path.isdir(directory):
    filename = ''

    while not os.path.isfile(f'{directory}/{filename}'):
      filename = random.choice(os.listdir(directory))

    mp3 = f'{directory}/{filename}'
    if blocking == 1:
      playsound(mp3)
    else:
      sound_thread = threading.Thread(target=playsound, args=(mp3,))
      sound_thread.start()
  return

def handler(signal_received, frame):
  remain_plural = 'edge' if edges == 1 else 'edges'
  complete_plural = 'edge' if edges_completed == 1 else 'edges'
  print()
  print(f'Aborted with {edges} {remain_plural} remaining.')
  print(f'{edges_completed} {complete_plural} completed.')
  exit(0)

if __name__ == '__main__':
  # Run handler() when SIGINT received
  signal(SIGINT, handler)

  main()
