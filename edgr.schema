drop table if exists sessions;
create table sessions (
  session_id    integer primary key autoincrement,
  user_id       integer,
  finished      integer default (strftime('%s','now')),
  length        real,
  min_safe      real,
  max_safe      real,
  goal          real,
  mean          real,
  stddev        real,
  prized        integer,
  scored        integer default 0
);

drop table if exists users;
create table users (
  user_id           integer primary key autoincrement,
  username          text
);
insert into users (username) values ('kinky');

drop table if exists sessions;
create table sessions (
  id                integer primary key autoincrement,
  inning_id         integer
);

drop table if exists session_settings;
create table session_settings (
  session_id        integer,
  key               text,
  val               text,
  priv              integer default 0,
  constraint session_setting (session_id, key)
);
  
drop table if exists user_settings;
create table user_settings (
  user_id           integer,
  key               text,
  val               text,
  priv              integer default 0,
  constraint user_setting (user_id, key)
);

insert into user_settings (user_id, key, val) values
  (1, 'bpm_min',          110),
  (1, 'bpm_max',          200),
  (1, 'end_zone_start',   120),
  (1, 'end_zone_length',  60),
  (1, 'time_min',         30),
  (1, 'time_max',         900),
  (1, 'slow_start',       120),
  (1, 'slow_interval',    30),
  (1, 'slow_trip',        0),
  (1, 'slow_rand',        1),
  (1, 'pass_per_draw',    1),
  (1, 'pass_per_fail',    0),
  (1, 'pass_per_slow',    0),
  (1, 'req_pass',         0),
  (1, 'req_pass_next',    0),
  (1, 'req_streak',       0),
  (1, 'req_streak_next',  0),
  (1, 'req_time',         0),
  (1, 'req_time_next',    0),
  (1, 'req_sess',         0),
  (1, 'req_sess_next',    0),
  (1, 'round',            1),
  (1, 'inning',           1),
  (1, 'cooldown',         900),
  (1, 'messages',         'all');

drop table if exists settings;
create table settings (
  setting_id        integer primary key autoincrement,
  user_id           integer,
  key               text,
  value             text,
  constraint setting_unique unique (user_id, key)
);

insert into settings (key, value, user_id) values
-- minimum beats per minute
  ('bpm_min',               100,      1),
-- maximum beats per minute
  ('bpm_max',               210,      1),
-- sessions owed to complete a challenge, completed back-to-back
  ('owed_streak',           0,        1),
-- number of passed sessions owed to complete a challenge
  ('owed_passes',           0,        1),
-- number of sessions to add when a session is failed, during a challenge
  ('owed_passes_add',       0,        1),
-- percent (pass / pass+fail) necessary to complete a challenge
  ('owed_percent',          0,        1),
-- value to reset owed_streak to when a challenge is completed
  ('owed_streak_default',   0,        1),
-- value to reset owed_passes to when a challenge is completed
  ('owed_passes_default',   0,        1),
-- value to reset owed_percent to when a challenge is completed
  ('owed_percent_default',  0,        1),
-- time (in seconds) before another session may be played
  ('session_break',         15*60,    1),
-- time (in seconds) another session must be played in to continue a streak
  ('session_break_max',     45*60,    1),
-- minimum time between applications of lube
  ('lube_break_min',        60,       1),
-- maximum time between applications of lube
  ('lube_break_max',        240,      1),
-- enable use of icy hot as lube
  ('prize_enabled',         1,        1),
-- percent chance to "arm" the icy hot rule
  ('prize_arm',             40,       1),
-- percent chance to "disarm" the icy hot rule
  ('prize_disarm',          42,       1),
-- whether or not icy hot is 'armed' / possible to be used
  ('prize_armed',           0,        1),
-- whether or not to fake icy hot being armed
  ('prize_fake',            0,        1),
-- percent chance that icy hot will be required
  ('prize_apply',           25,       1),
-- time in seconds for a fixed goal (-1 = use mean)
  ('goal',                   -1,      1),
-- time in seconds to sub from 'goal' to define the "pass window"
  ('goal_pre',              180,      1),
-- time in seconds to add to 'goal' to define the "pass window"
  ('goal_window',           180,      1),
-- minimum time in seconds that the goal time may be
  ('goal_min',              300,      1),
-- maximum time in seconds that the goal time may be
  ('goal_max',              1800,     1),
-- value to use for 'mean' when min_sessions have not been completed
  ('mean_default',          540,      1),
-- value to use for 'stddev' when min_sessions have not been completed
  ('stddev_default',        120,      1),
-- time in seconds that a session may be aborted and not counted
  ('too_short',             30,       1),
-- number of days to consider previous sessions when creating the goal
  ('history',               15,       1),
-- number of sessions to consider when creating the goal
  ('history_max',           20,       1),
-- minimum number of sessions before mean_default / stddev_default not used
  ('min_sessions',          5,        1);

